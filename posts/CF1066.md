## Rating赛后小结〖2〗

首先是最阳间的一场，17:35分的CF你敢信，你见过傍晚17:35分的d1+d2吗(?非常精神啊，不用半夜熬老头了，哥们身体真不行，一到晚上就一蹶不振，精神涣散，思维迟钝，一天最清醒的时候是早上七点半到九点半，纯纯的小镇做题家机器，唉没救了。

1066d1+d2 D，一开始联想到凸函数性质，以为是绝对值函数的叠加，想到了之前做过的一道题用堆优化凸函数dp，然后发现不太一样，把玩了几个样例之后，发现令k尽可能接近于0的时候有最优解，且b要尽可能大，然后敲一下三种情况的判断，叠加不同的k和b，遂过之。第一次赛中过d2的D题，零基础小白那叫一个激动啊。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
#define pb push_back
#define rep(i,a,b,c) for(int i=(a);i<(b);i+=(c))
#define per(i,a,b,c) for(int i=(a);i>=(b);i-=(c))
typedef long long ll;
typedef vector<int> vi;
typedef vector<vector<int>> vii;
typedef vector<vector<vector<int>>> viii;
typedef pair<int,int> pii;
typedef tuple<int,int,int> piii;
const ll inf=1e18;
const ll N=100010;
const ll mod=998244353;
const double eps=1e-6;
struct PairHash{
    size_t operator()(const pii& p)const{
        auto h1=hash<int>{}(p.first),h2=hash<int>{}(p.second);
        return h1^(h2+0x9e3779b9+(h1<<6)+(h1>>2));
    }
};

void solve(){
    int n,l,r;
    cin>>n>>l>>r;
    vi A(n,0);
    int res=0;
    int k=0,b=0;
    vi g;
    rep(i,0,n,1){
        cin>>A[i];
        if(A[i]>r){
            k-=1;
            b+=A[i];
        }
        else if(A[i]<l){
            k+=1;
            b-=A[i];
        }
        else{
            g.pb(A[i]);
        }
    }
    int m=g.size();
    sort(g.begin(),g.end());
    int ll=0,rr=m-1;
    while(ll<=rr){
        if(abs(k)<=0){
            b+=g[rr]-g[ll];
            ll++,rr--;
        }
        else{
            if(k>0){
                k--;
                b+=g[rr];
                rr--;
            }
            else{
                k++;
                b-=g[ll];
                ll++;
            }
        }
    }
    if(k>=0){
        res=k*l+b;
    }
    else{
        res=k*r+b;
    }
    cout<<res<<endl;
}

void init(){
    ;
}

signed main() {
    ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
    int T=1;
    cin>>T;init();
    while(T--)
    	solve();
    return 0;
}
```

1066d1+d2 C构造题，不会，寄了....吗？好吧，开完D之后士气大涨，回头开C，很快就切掉了，思路是先满足比较容易满足的，先把数组全部初始化为100，第一次遍历记录哪些位置 可以被改为k 或是 不能被改为k以下 的数字位置，然后先把min给满足了，然后再去把mex给满足，希望不会被hack就是了呜呜呜。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
#define pb push_back
#define rep(i,a,b,c) for(int i=(a);i<(b);i+=(c))
#define per(i,a,b,c) for(int i=(a);i>=(b);i-=(c))
typedef long long ll;
typedef vector<int> vi;
typedef vector<vector<int>> vii;
typedef vector<vector<vector<int>>> viii;
typedef pair<int,int> pii;
typedef tuple<int,int,int> piii;
const ll inf=1e18;
const ll N=100010;
const ll mod=998244353;
const double eps=1e-6;
struct PairHash{
    size_t operator()(const pii& p)const{
        auto h1=hash<int>{}(p.first),h2=hash<int>{}(p.second);
        return h1^(h2+0x9e3779b9+(h1<<6)+(h1>>2));
    }
};

void solve(){
    int n,k,q;
    cin>>n>>k>>q;
    vi A(n+1,100);

    vi mustbe(n+1,0);
    vi cannot(n+1,0);
    vii g;
    vii mex;
    rep(i,0,q,1){
        int c,l,r;
        cin>>c>>l>>r;
        if(c==1){
            g.pb({l,r});
            rep(j,l,r+1,1){
                mustbe[j]=1;
            }
        }
        else{
            mex.pb({l,r});
            rep(j,l,r+1,1){
                cannot[j]=1;
            }
        }
    }

    for(auto& e:g){
        int l=e[0],r=e[1];
        int flag=0;
        rep(i,l,r+1,1){
            if(A[i]==k){
                flag=1;
                break;
            }
        }
        if(flag==1)
            continue;
        rep(i,l,r+1,1){
            if(cannot[i]==0){
                A[i]=k;
                break;
            }
        }
    }

    sort(mex.begin(),mex.end());
    for(auto& e:mex){
        int l=e[0],r=e[1];
        vi cnt(101,0);
        rep(i,l,r+1,1){
            cnt[A[i]]++;
        }
        rep(i,0,k,1){
            if(cnt[i])
                continue;
            rep(j,l,r+1,1){
                if(mustbe[j]==0&&A[j]==100){
                    A[j]=i;
                    break;
                }
            }
        }
    }
    rep(i,1,n+1,1)
        cout<<A[i]<<" ";
    cout<<endl;
}

void init(){
    ;
}

signed main() {
    ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
    int T=1;
    cin>>T;init();
    while(T--)
    	solve();
    return 0;
}
```

1066d1+d2 E感觉是简单的模拟，没啥时间做了，下次如果还有傍晚的3h场希望能做得更好！